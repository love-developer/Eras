/* AUTOGENERATED FILE - DO NOT EDIT CONTENTS */

/* Table schema:
CREATE TABLE kv_store_f9be53a7 (
  key TEXT NOT NULL PRIMARY KEY,
  value JSONB NOT NULL
);
*/

// View at https://supabase.com/dashboard/project/apdfvpgaznpqlordkipw/database/tables

// This file provides a simple key-value interface for storing Figma Make data. It should be adequate for most small-scale use cases.
import { createClient } from "jsr:@supabase/supabase-js";

const client = () => {
  const url = Deno.env.get("SUPABASE_URL");
  const key = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
  
  if (!url) {
    throw new Error("SUPABASE_URL environment variable is not set");
  }
  
  if (!key) {
    throw new Error("SUPABASE_SERVICE_ROLE_KEY environment variable is not set");
  }
  
  try {
    return createClient(url, key);
  } catch (error) {
    throw new Error(`Failed to create Supabase client: ${error.message}`);
  }
};

// Set stores a key-value pair in the database.
export const set = async (key: string, value: any): Promise<void> => {
  try {
    const supabase = client();
    const { error } = await supabase.from("kv_store_f9be53a7").upsert({
      key,
      value
    });
    
    if (error) {
      // Detect Cloudflare HTML errors to avoid verbose logging
      const errorMsg = error.message || String(error);
      const isCloudflareError = errorMsg.includes('<html>') || 
                                errorMsg.includes('cloudflare') || 
                                errorMsg.includes('Internal Server Error');
      
      if (isCloudflareError) {
        console.warn(`‚ö†Ô∏è KV Store: Database timeout/error setting key "${key}" (Cloudflare 500)`);
        // Don't throw for Cloudflare errors - they're often transient
        return;
      }
      
      throw new Error(error.message);
    }
  } catch (error) {
    // Detect Cloudflare HTML errors
    const errorMsg = error?.message || String(error);
    const isCloudflareError = errorMsg.includes('<html>') || 
                              errorMsg.includes('cloudflare') || 
                              errorMsg.includes('Internal Server Error');
    
    if (isCloudflareError) {
      console.warn(`‚ö†Ô∏è KV Store: Transient error setting key "${key}" - ignoring`);
      // Don't throw for Cloudflare errors - they're often transient
      return;
    }
    
    throw error;
  }
};

// Get retrieves a key-value pair from the database.
export const get = async (key: string): Promise<any> => {
  try {
    console.log(`üì• KV Store: Getting key "${key}"`);
    
    const supabase = client();
    
    // Validate client creation
    if (!supabase) {
      throw new Error("Failed to create Supabase client");
    }
    
    console.log("üîó KV Store: Supabase client created, executing query...");
    
    // Add timeout protection directly in the query - Increased to 30s for stability
    const queryPromise = supabase
      .from("kv_store_f9be53a7")
      .select("value")
      .eq("key", key)
      .maybeSingle();
    
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error(`Query timeout for key: ${key}`)), 30000)
    );
    
    let result;
    try {
      result = await Promise.race([queryPromise, timeoutPromise]);
    } catch (timeoutError) {
      // Handle timeout specifically
      console.error(`‚è±Ô∏è KV Store: Query timed out for key \"${key}\" after 30 seconds`);
      throw new Error(`Database query timeout: The server took too long to respond for key \"${key}\"`);
    }
    
    const { data, error } = result as any;
    
    if (error) {
      // Handle undefined or null error messages (network/gateway errors)
      const errorMsg = error?.message || error?.msg || String(error) || 'Unknown database error';
      const errorCode = error?.code || error?.status || 'unknown';
      const errorDetails = error?.details || error?.hint || '';
      
      // Combine message and details for thorough error detection
      const fullErrorText = `${errorMsg} ${errorDetails}`.toLowerCase();
      
      // Detect various error types
      const isCloudflareError = errorMsg.includes('<html>') || 
                                errorMsg.includes('cloudflare') || 
                                errorMsg.includes('Internal Server Error');
      
      const isNetworkError = fullErrorText.includes('network') ||
                            fullErrorText.includes('fetch') ||
                            fullErrorText.includes('http2 error') ||
                            fullErrorText.includes('connection error') ||
                            fullErrorText.includes('sendrequest') ||
                            fullErrorText.includes('econnreset') ||
                            fullErrorText.includes('etimedout');
      
      const isUndefinedError = errorMsg === 'Unknown database error' || 
                              errorMsg === 'undefined' || 
                              errorMsg === '[object Object]';
      
      // Log appropriately based on error type
      if (isCloudflareError) {
        console.warn(`‚ö†Ô∏è KV Store: Database timeout/error for key "${key}" (Cloudflare 500)`);
      } else if (isNetworkError) {
        console.warn(`‚ö†Ô∏è KV Store: Network/HTTP2 error for key "${key}" (transient infrastructure issue)`);
      } else if (isUndefinedError) {
        console.warn(`‚ö†Ô∏è KV Store: Undefined database response for key "${key}" (likely gateway/network issue)`);
      } else {
        console.error(`‚ùå KV Store: Database error for key "${key}":`, error);
      }
      
      // Throw appropriate error messages
      if (isNetworkError || isUndefinedError) {
        throw new Error(`Network connection lost${errorDetails ? ': ' + errorDetails : ''}`);
      } else {
        throw new Error(`Database error: ${errorMsg} (Code: ${errorCode})`);
      }
    }
    
    console.log(`‚úÖ KV Store: Successfully retrieved key "${key}"`);
    return data?.value;
  } catch (error) {
    // Detect various error types for proper handling
    const errorMsg = error?.message || String(error);
    const errorDetails = error?.details || '';
    const fullErrorText = `${errorMsg} ${errorDetails}`.toLowerCase();
    
    const isCloudflareError = errorMsg.includes('<html>') || 
                              errorMsg.includes('cloudflare') || 
                              errorMsg.includes('Internal Server Error');
    
    const isNetworkError = fullErrorText.includes('network') ||
                          fullErrorText.includes('fetch') ||
                          fullErrorText.includes('http2 error') ||
                          fullErrorText.includes('connection error') ||
                          fullErrorText.includes('sendrequest') ||
                          fullErrorText.includes('econnreset') ||
                          fullErrorText.includes('etimedout');
    
    // Only log non-transient errors
    if (!isCloudflareError && !isNetworkError) {
      console.error(`üí• KV Store: Exception for key "${key}":`, error);
    }
    
    // Re-throw with appropriate context
    if (isNetworkError) {
      throw new Error(`Network connection lost`);
    }
    
    throw error;
  }
};

// Delete deletes a key-value pair from the database.
export const del = async (key: string): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_f9be53a7").delete().eq("key", key);
  if (error) {
    throw new Error(error.message);
  }
};

// Sets multiple key-value pairs in the database.
export const mset = async (keys: string[], values: any[]): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_f9be53a7").upsert(keys.map((k, i) => ({ key: k, value: values[i] })));
  if (error) {
    throw new Error(error.message);
  }
};

// Gets multiple key-value pairs from the database.
export const mget = async (keys: string[]): Promise<any[]> => {
  const supabase = client()
  const { data, error } = await supabase.from("kv_store_f9be53a7").select("value").in("key", keys);
  if (error) {
    throw new Error(error.message);
  }
  return data?.map((d) => d.value) ?? [];
};

// Deletes multiple key-value pairs from the database.
export const mdel = async (keys: string[]): Promise<void> => {
  const supabase = client()
  const { error } = await supabase.from("kv_store_f9be53a7").delete().in("key", keys);
  if (error) {
    throw new Error(error.message);
  }
};

// Search for key-value pairs by prefix.
export const getByPrefix = async (prefix: string, timeoutMs: number = 15000): Promise<any[]> => {
  try {
    console.log(`üì• KV Store: Getting by prefix "${prefix}" (timeout: ${timeoutMs}ms)...`);
    const startTime = Date.now();
    
    const supabase = client();
    
    // Create a timeout promise
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => {
        const elapsed = Date.now() - startTime;
        console.error(`‚ùå KV Store: Query timed out after ${elapsed}ms for prefix "${prefix}"`);
        reject(new Error(`Database query timeout after ${timeoutMs / 1000} seconds - server not responding`));
      }, timeoutMs);
    });
    
    // Execute the query and race it against timeout
    // IMPORTANT: Use .limit() to prevent fetching too many records
    console.log(`üîç KV Store: Executing query for prefix "${prefix}"...`);
    const queryPromise = (async () => {
      const result = await supabase
        .from("kv_store_f9be53a7")
        .select("key, value")
        .like("key", prefix + "%")
        .limit(1000); // Reasonable limit to prevent huge queries
      
      const elapsed = Date.now() - startTime;
      console.log(`‚è±Ô∏è KV Store: Query completed in ${elapsed}ms`);
      return result;
    })();
    
    const { data, error } = await Promise.race([queryPromise, timeoutPromise]) as any;
    
    if (error) {
      console.error(`‚ùå KV Store: Database error for prefix "${prefix}":`, error);
      throw new Error(`Database error: ${error.message}`);
    }
    
    const elapsed = Date.now() - startTime;
    console.log(`‚úÖ KV Store: Successfully retrieved ${data?.length || 0} items with prefix "${prefix}" in ${elapsed}ms`);
    return data?.map((d: any) => d.value) ?? [];
  } catch (error) {
    console.error(`üí• KV Store: Exception for prefix "${prefix}":`, error.message || error);
    
    // Check if it's a timeout or connection error
    if (error.message?.includes('timeout') || 
        error.message?.includes('fetch') || 
        error.message?.includes('network') ||
        error.message?.includes('502') ||
        error.message?.includes('Bad Gateway') ||
        error.message?.includes('not responding')) {
      throw new Error(`Database connection issue: ${error.message}`);
    }
    
    throw error;
  }
};